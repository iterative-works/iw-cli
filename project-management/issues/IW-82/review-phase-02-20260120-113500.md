# Code Review Results

**Review Context:** Phase 2: Load sample data for UI testing for issue IW-82 (Iteration 1/3)
**Files Reviewed:** 5 files
**Skills Applied:** 3 (style, testing, scala3)
**Timestamp:** 2026-01-20 11:35:00
**Git Context:** git diff c6483d6

---

<review skill="style">

## Code Style & Documentation Review

### Critical Issues

None found.

### Warnings

#### Mutable Variables in Argument Parsing
**Location:** `.iw/commands/dashboard.scala:14-17`
**Problem:** Using mutable `var` for `statePath`, `sampleData`, and `i` in the argument parsing logic violates functional programming principles.
**Impact:** Goes against the project's stated preference for immutable values and pure functions. Makes the code harder to reason about and test.
**Recommendation:** Refactor to use a tail-recursive function or fold pattern with immutable accumulator.

#### Inconsistent Comment Formatting
**Location:** `.iw/core/test/TestFixtures.scala:264, 277, 290, 337, 348, 359, 370`
**Problem:** Inline comments use inconsistent style - some describe the variable assignment, others add context about the data.
**Impact:** Minor readability inconsistency across the large sample data fixture.
**Recommendation:** Be consistent - either use Scaladoc for sample data descriptions or keep inline comments to a minimum.

### Suggestions

#### Consider Enum for Argument Parsing States
**Location:** `.iw/commands/dashboard.scala:12-29`
**Problem:** Argument parsing uses pattern matching on strings directly without a clear state machine.
**Impact:** For future extensibility, adding more flags may become unwieldy.
**Recommendation:** Consider using Scala 3 enums or ADTs to represent parsed CLI arguments for better type safety.

#### Magic Numbers in Timestamp Calculations
**Location:** `.iw/core/test/TestFixtures.scala:453-488` and similar locations
**Problem:** Hardcoded millisecond values like `3600000`, `86400000`, `172800000` reduce readability.
**Impact:** Makes it harder to understand what time periods these represent without calculation.
**Recommendation:** Define named constants for common time periods or use helper methods.

#### Scaladoc Could Be More Consistent
**Location:** All test files
**Problem:** The Scaladoc documentation is good overall, but some methods use active voice while others use descriptive nouns.
**Impact:** Minor inconsistency in documentation style.
**Recommendation:** Standardize on one style.

</review>

---

<review skill="testing">

## Unit Testing Review

### Critical Issues

None found.

### Warnings

#### Test Coverage Missing for Dashboard Command Integration
**Location:** `.iw/commands/dashboard.scala:12-61`
**Problem:** The dashboard command's sample data integration logic (argument parsing, file writing, verification) lacks unit tests. Critical code paths including error handling, argument validation, and the sample data generation + persistence flow are not covered by automated tests.
**Impact:** Changes to command-line parsing or sample data initialization could break without detection.
**Recommendation:** Add unit tests for the dashboard command's sample data functionality.

#### Test Missing for SampleDataGenerator Determinism Over Time
**Location:** `.iw/core/domain/SampleDataGenerator.scala:31-33`
**Problem:** The determinism test only checks worktree keys, but doesn't verify that timestamps generated from `Instant.now()` are consistent within a single call.
**Impact:** The test claims determinism but doesn't actually verify it for timestamp-based fields.
**Recommendation:** Clarify what "deterministic" means for this generator or use a fixed base time for testing.

### Suggestions

#### Consider Extracting Test Data Builders
**Location:** `.iw/core/test/TestFixtures.scala:755-1171`
**Problem:** The `SampleData` object mixes test fixtures with production-like sample data generation, duplicating logic from `SampleDataGenerator.scala`.
**Impact:** Duplication increases maintenance burden.
**Recommendation:** Consider refactoring to use composition where `SampleData` delegates to `SampleDataGenerator`.

#### Test Names Could Be More Behavior-Focused
**Location:** `.iw/core/test/SampleDataTest.scala` (multiple locations)
**Problem:** Test names focus on implementation details rather than behavior or requirements.
**Impact:** Tests read like API documentation rather than specification of behavior.
**Recommendation:** Consider more behavior-focused test names.

#### Add Property-Based Tests for Sample Data Validity
**Location:** `.iw/core/test/SampleDataGeneratorTest.scala` (entire file)
**Problem:** Current tests check specific counts but don't validate invariants.
**Impact:** Broken relationships between caches could slip through tests.
**Recommendation:** Add property-based tests for data integrity.

#### Test for State Serialization Round-Trip Completeness
**Location:** `.iw/core/test/SampleDataGeneratorTest.scala:94-118`
**Problem:** The serialization test only checks counts after round-trip, not deep equality.
**Impact:** Subtle serialization bugs won't be caught.
**Recommendation:** Enhance the round-trip test to verify deep equality.

</review>

---

<review skill="scala3">

## Scala 3 Idioms Review

### Critical Issues

None found.

### Warnings

#### Imperative Command-Line Argument Parsing with Mutable Variables
**Location:** `.iw/commands/dashboard.scala:14-29`
**Problem:** Using `var` and `while` loop for command-line parsing is an imperative Scala 2 pattern
**Impact:** Less functional, harder to test, and doesn't leverage Scala's pattern matching capabilities for argument parsing
**Recommendation:** Use functional pattern matching with recursion or `foldLeft` to parse arguments immutably

### Suggestions

#### Consider Opaque Types for Issue IDs in Sample Data
**Location:** `.iw/core/domain/SampleDataGenerator.scala:37-77` and `.iw/core/test/TestFixtures.scala:758-801`
**Problem:** Issue IDs are represented as plain `String` values throughout sample data generation
**Impact:** While not a bug, using plain strings for domain identifiers misses an opportunity for type safety
**Recommendation:** Consider using opaque types if not already available in the codebase
**Note:** The codebase already has `IssueId.parse` used elsewhere, suggesting this might already exist.

#### Lazy Val Usage is Appropriate
**Location:** `.iw/core/test/TestFixtures.scala:758+` (all sample data definitions)
**Problem:** None - this is correct usage
**Impact:** Using `lazy val` for sample data fixtures is the right pattern in Scala 3
**Recommendation:** No change needed - correct pattern for test fixtures with timestamps.

</review>

---

## Summary

- **Critical issues:** 0 (must fix before merge)
- **Warnings:** 4 (should fix)
- **Suggestions:** 9 (nice to have)

### By Skill
- style: 0 critical, 2 warnings, 3 suggestions
- testing: 0 critical, 2 warnings, 5 suggestions
- scala3: 0 critical, 1 warning, 1 suggestion (1 item is a "no change needed" positive finding)

### Recurring Theme

The most significant feedback across all reviewers is the imperative argument parsing in `dashboard.scala`. While functional for the current use case, it violates the project's functional programming principles. This is a **warning**, not critical, because:
- The code works correctly
- It's isolated to a small CLI command
- The main implementation (SampleDataGenerator) is properly functional

The warnings are recommendations for improvement, not blockers for merge.
