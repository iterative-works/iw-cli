# Code Review Results

**Review Context:** Refactoring R2: Add update command for Phase 3 of IW-136 (Iteration 1/3)
**Files Reviewed:** 9 files
**Skills Applied:** 6 (architecture, scala3, composition, testing, style, security)
**Timestamp:** 2026-02-03 11:33:28
**Git Context:** git diff db175ba

---

<review skill="architecture">

## Architecture Review

### Critical Issues

None found.

### Warnings

#### Shell Effects Leaking Into Command Scripts
**Location:** `.iw/commands/review-state/validate.scala:24-30`, `.iw/commands/review-state/write.scala:37-73`, `.iw/commands/review-state/update.scala:70-184`
**Problem:** Command scripts contain I/O operations (reading stdin, reading/writing files) mixed with business logic (validation, merging). While these are "shell scripts" by nature, they could be better organized following FCIS principles.
**Impact:** Makes testing harder and mixes concerns. The command scripts are doing both orchestration AND I/O operations directly.
**Recommendation:** Consider extracting file I/O operations into `core/adapters/` module. The command scripts would become thin orchestration layers:

```scala
// Current (in validate.scala)
val json =
  if useStdin then
    scala.io.Source.stdin.mkString
  else
    val path = os.Path(filePaths.head, os.pwd)
    if !os.exists(path) then
      Output.error(s"File not found: $path")
      sys.exit(1)
    os.read(path)

// Suggested refactoring
// In core/adapters/FileAdapter.scala
def readJsonSource(path: Option[String], useStdin: Boolean): Either[String, String] = ...

// In validate.scala
FileAdapter.readJsonSource(filePaths.headOption, useStdin) match
  case Left(err) =>
    Output.error(err)
    sys.exit(1)
  case Right(json) =>
    // validation logic
```

This isn't critical since command scripts are inherently imperative shells, but it would improve testability.

#### Dispatcher Pattern Could Be Simplified
**Location:** `.iw/commands/review-state.scala:40-77`
**Problem:** The dispatcher uses `scala-cli` subprocess execution to run subcommands. This creates process overhead and makes the architecture more complex than necessary.
**Impact:** Performance overhead from spawning scala-cli for each subcommand. Harder to debug and test the command orchestration.
**Recommendation:** Consider importing subcommand objects directly and calling them:

```scala
// Current approach (subprocess)
val command = List("scala-cli", "run", ..., scriptPath.toString) ++ coreFiles ++ ...
val result = os.proc(command).call(...)

// Alternative approach (direct invocation)
import reviewstate.{validate, write, update}
subcommand match
  case "validate" => validate.main(subcommandArgs*)
  case "write" => write.main(subcommandArgs*)
  case "update" => update.main(subcommandArgs*)
```

This would require organizing subcommands as objects with main methods, but would eliminate subprocess overhead. Not critical for correctness, but worth considering for performance.

### Suggestions

#### Consider Adapter Layer for Git Operations
**Location:** `.iw/commands/review-state/write.scala:72-73`, `.iw/commands/review-state/update.scala:48-56`
**Problem:** Commands directly call `GitAdapter.getCurrentBranch()` and `IssueId.fromBranch()` - this is correct use of adapters, but the error handling is duplicated across both files.
**Impact:** Minor code duplication in error handling.
**Recommendation:** Extract common pattern to adapter:

```scala
// In core/adapters/IssueIdAdapter.scala
def inferFromCurrentBranch(cwd: os.Path): Either[String, IssueId] =
  GitAdapter.getCurrentBranch(cwd).flatMap(IssueId.fromBranch)

// In commands
IssueIdAdapter.inferFromCurrentBranch(os.pwd) match
  case Right(id) => id
  case Left(err) =>
    Output.error(s"Cannot infer issue ID: $err")
    Output.info("Use --issue-id to specify explicitly")
    sys.exit(1)
```

This consolidates the common pattern and makes it easier to test.

#### Test Organization Could Mirror Production Structure
**Location:** `.iw/core/test/ReviewStateUpdaterTest.scala:1`
**Problem:** Test file is in `core/test/` but the production code is in `core/model/`. While this works, it doesn't mirror the production structure.
**Impact:** Makes it slightly harder to find corresponding tests for production code.
**Recommendation:** Consider organizing tests to mirror production:
- Production: `.iw/core/model/ReviewStateUpdater.scala`
- Test: `.iw/core/model/ReviewStateUpdaterTest.scala` (not `.iw/core/test/ReviewStateUpdaterTest.scala`)

This is just a suggestion for consistency - current structure is acceptable.

#### Document FCIS Boundaries in Architecture
**Location:** Throughout refactored code
**Problem:** The refactoring successfully implements FCIS (pure domain logic in `ReviewStateUpdater`, I/O in commands), but this architectural decision isn't explicitly documented.
**Impact:** Future developers might not understand the boundary and could accidentally add I/O to `ReviewStateUpdater`.
**Recommendation:** Add architecture comments to key files:

```scala
// In ReviewStateUpdater.scala
/**
 * Pure merge logic for updating review-state.json.
 *
 * ARCHITECTURE: This is part of the functional core (FCIS pattern).
 * NO I/O operations allowed here. All functions must be pure.
 * - Input: JSON string + update specification
 * - Output: Merged JSON string
 * - No file operations, no timestamps (timestamp provided by caller)
 */
object ReviewStateUpdater:
  ...
```

This makes the architectural boundaries explicit and self-documenting.

</review>

---

<review skill="scala3">

## Scala 3 Idioms Review

### Critical Issues

None found.

### Warnings

None found.

### Suggestions

#### Consider Opaque Type for Issue ID String
**Location:** `.iw/commands/review-state/update.scala:48-56`
**Problem:** Issue ID is handled as raw `String` throughout the command
**Impact:** Minor - prevents mixing up issue IDs with other strings at compile time
**Recommendation:** The codebase already has `IssueId.fromBranch` which returns `Either[String, IssueId]`, suggesting a domain type exists. However, the command extracts `.value` immediately (line 66), converting back to String. Consider keeping the domain type longer in the pipeline.

```scala
// Current (line 48-56, then 66)
val issueId = extractFlag(argList, "--issue-id") match
  case Some(id) => id
  case None =>
    GitAdapter.getCurrentBranch(os.pwd).flatMap(IssueId.fromBranch) match
      case Right(id) => id.value  // Converts to String immediately
      case Left(err) => ...

// Consider keeping IssueId type
val issueId: IssueId = extractFlag(argList, "--issue-id") match
  case Some(id) => IssueId(id)  // Assuming constructor exists
  case None =>
    GitAdapter.getCurrentBranch(os.pwd).flatMap(IssueId.fromBranch) match
      case Right(id) => id
      case Left(err) => ...
```

**Note:** This is a minor suggestion and depends on how `IssueId` is implemented elsewhere in the codebase. If `IssueId` is already an opaque type or case class, this would provide better type safety. However, if the domain model intentionally uses raw strings for simplicity, the current approach is acceptable.

---

#### Excellent Use of Scala 3 Enum
**Location:** `.iw/core/model/ReviewStateUpdater.scala:46-49`
**Observation:** The code correctly uses Scala 3's `enum` for `ArrayMergeMode`
**Benefit:** This is exactly the right pattern - simple ADT with three fixed variants, all in one place, no complex inheritance needed.

```scala
enum ArrayMergeMode:
  case Replace  // Replace entire array with provided values
  case Append   // Add provided values to existing array
  case Clear    // Remove all values (provided values ignored)
```

This is a textbook example of when to use Scala 3 enums over sealed traits. The code demonstrates good Scala 3 idiom adoption.

---

#### Good Pattern Matching with No Union Type Issues
**Location:** Throughout all files
**Observation:** All pattern matching uses appropriate Either types for error handling workflows
**Benefit:** The code correctly uses `Either` for operations that need combinators and proper error handling flow (e.g., `GitAdapter.getCurrentBranch(...).flatMap(IssueId.fromBranch)` in update.scala:51), rather than union types. This is the correct choice for this use case.

</review>

---

<review skill="composition">

## Composition Patterns Review

### Critical Issues

None found.

### Warnings

#### Code Duplication in Flag Parsing Across Multiple Commands
**Location:** `.iw/commands/review-state/write.scala:179-187` and `.iw/commands/review-state/update.scala:187-195`
**Problem:** The `extractFlag` and `extractRepeatedFlag` helper functions are duplicated identically in both `write.scala` and `update.scala` command files.
**Impact:** Violates DRY (Don't Repeat Yourself) principle. Changes to flag parsing logic must be maintained in multiple locations, increasing maintenance burden and risk of inconsistency.
**Recommendation:** Extract these shared parsing functions into a reusable module.

```scala
// Create .iw/core/model/ArgParser.scala
package iw.core.model

object ArgParser:
  def extractFlag(args: List[String], flag: String): Option[String] =
    val idx = args.indexOf(flag)
    if idx >= 0 && idx + 1 < args.length then Some(args(idx + 1))
    else None

  def extractRepeatedFlag(args: List[String], flag: String): List[String] =
    args.sliding(2).collect {
      case List(`flag`, value) if !value.startsWith("--") => value
    }.toList

// Then in write.scala and update.scala:
import iw.core.model.ArgParser

// Use ArgParser.extractFlag(...) and ArgParser.extractRepeatedFlag(...)
```

#### Procedural Array Parsing Logic
**Location:** `.iw/commands/review-state/update.scala:94-140`
**Problem:** The array field parsing pattern is repeated nearly identically for five different array types (artifacts, badges, taskLists, actions, phaseCheckpoints). Each follows the same structure with only the flag names and parsing function differing.
**Impact:** High code duplication (~50 lines repeated 5 times). Adding a new array field requires copying and modifying this pattern. The repetition makes the code harder to maintain and increases the chance of inconsistencies.
**Recommendation:** Extract a generic composition pattern that captures the common structure.

```scala
// In update.scala, create a composed parser:
private def parseArrayFields[T](
  args: List[String],
  fields: List[(String, String, String, String => T)]
): List[(Option[List[T]], ReviewStateUpdater.ArrayMergeMode)] =
  fields.map { case (name, replaceFlag, appendFlag, clearFlag) =>
    parseArrayField(args, replaceFlag, appendFlag, clearFlag)(identity)
  }

// Define field configurations as data:
val arrayFieldConfigs = List(
  ("artifacts", "--artifact", "--append-artifact", "--clear-artifacts",
    parseArtifact _),
  ("badges", "--badge", "--append-badge", "--clear-badges",
    parseBadge _),
  // ... etc
)

// Then parse all at once:
val parsedFields = arrayFieldConfigs.map { case (name, replace, append, clear, parser) =>
  parseArrayField(args, replace, append, clear)(parser)
}
```

Alternatively, since the pattern is consistent, consider extracting to a dedicated `ArrayFieldParser` component that can be composed.

### Suggestions

#### Consider Function Composition for Parsing Pipeline
**Location:** `.iw/commands/review-state/write.scala:87-130`
**Problem:** The flag parsing code uses sequential imperative-style parsing with many `val` bindings for extracting and transforming flag values.
**Impact:** Minor. The code is readable but could benefit from composition patterns to make the transformation pipeline more explicit.
**Recommendation:** Consider extracting pure parsing functions and composing them for clarity.

```scala
// Current imperative style:
val badges = extractRepeatedFlag(argList, "--badge").map { raw =>
  val parts = raw.split(":", 2)
  if parts.length < 2 then
    Output.error(s"Invalid badge format '$raw', expected label:type")
    sys.exit(1)
  (parts(0), parts(1))
}

// Alternative with composed validators:
def parseBadgeFormat(raw: String): Either[String, (String, String)] =
  val parts = raw.split(":", 2)
  if parts.length < 2 then Left(s"Invalid badge format '$raw', expected label:type")
  else Right((parts(0), parts(1)))

val badges = extractRepeatedFlag(argList, "--badge")
  .traverse(parseBadgeFormat)
  .getOrElse { err =>
    Output.error(err)
    sys.exit(1)
  }
```

This makes the parsing logic testable independently and composable across different flag types.

#### Display Object Merge Logic Could Be More Modular
**Location:** `.iw/core/model/ReviewStateUpdater.scala:96-112`
**Problem:** The display object merging logic is embedded directly in the main `merge` function with conditional branches for clearing and partial updates.
**Impact:** The merge function is relatively long (100+ lines) with multiple responsibilities. While not a "god object," it could benefit from breaking down complex merge operations into smaller, composable pieces.
**Recommendation:** Extract display merging into a separate function.

```scala
// Extract to smaller, focused function:
private def mergeDisplay(
  existing: ujson.Value,
  displayText: Option[String],
  displaySubtext: Option[String],
  displayType: Option[String],
  clearDisplay: Boolean,
  clearDisplaySubtext: Boolean
): Unit =
  if clearDisplay then
    existing.obj.remove("display")
  else if displayText.isDefined || displaySubtext.isDefined || displayType.isDefined || clearDisplaySubtext then
    val displayObj = existing.obj.get("display") match
      case Some(obj: ujson.Obj) => obj
      case _ => ujson.Obj()

    displayText.foreach(v => displayObj("text") = ujson.Str(v))
    displayType.foreach(v => displayObj("type") = ujson.Str(v))

    if clearDisplaySubtext then displayObj.obj.remove("subtext")
    else displaySubtext.foreach(v => displayObj("subtext") = ujson.Str(v))

    existing("display") = displayObj

// Then in merge():
mergeDisplay(existing, update.displayText, update.displaySubtext,
             update.displayType, update.clearDisplay, update.clearDisplaySubtext)
```

This would make the `merge` function more declarative and each merge operation independently testable.

#### Dispatcher Pattern Uses Process Spawning Instead of Direct Composition
**Location:** `.iw/commands/review-state.scala:40-78`
**Problem:** The dispatcher uses `scala-cli` subprocess spawning to execute subcommands rather than importing and calling them directly.
**Impact:** This is not necessarily wrong (it's appropriate for the scala-cli architecture), but it means the commands cannot be composed at the function level. This is more of an architectural observation than a code smell.
**Recommendation:** No change needed for current architecture. However, if you wanted more testability or direct composition, you could structure the commands as:
  1. Pure business logic functions in `core/model/`
  2. Thin command wrappers that call those functions
  3. Dispatcher that can either call directly or spawn processes

This would enable composition at the logic level while maintaining the current command structure for CLI use.

</review>

---

<review skill="testing">

## Unit Testing Review

### Critical Issues

None found.

### Warnings

#### E2E Test Marked as Skip Without Clear Resolution Path
**Location:** `.iw/test/review-state.bats:378-387`
**Problem:** Test "validation failed - exit 1, file not modified" is skipped with comment "Need to design a way to create invalid state through update"
**Impact:** Missing test coverage for a critical error path - ensuring invalid updates don't corrupt existing files
**Recommendation:** Either remove the skipped test or implement it. One approach: manually create an invalid JSON state that the validator will reject (e.g., missing required fields after merge), then verify the file wasn't modified. Alternatively, test that validation runs before writing by checking the original file timestamp hasn't changed.

```bats
@test "review-state update: validation failed - exit 1, file not modified" {
    # Create initial valid state
    echo '{"version":2,"issue_id":"IW-1","artifacts":[],"last_updated":"2026-01-01T12:00:00Z"}' > "$TEST_TMPDIR/state.json"

    # Get original timestamp
    local original_time
    original_time=$(stat -c %Y "$TEST_TMPDIR/state.json")

    # Try to update with invalid combination (e.g., display-text without display-type)
    # This should fail validation in the merge logic
    # Note: Current implementation may prevent this at build time
    # Alternative: Test with corrupted existing file that merge would make worse

    # For now, test that validator catches issues by corrupting the merged result
    # (This requires the implementation to validate BEFORE writing)
    sleep 1  # Ensure timestamp would change

    run "$PROJECT_ROOT/iw" review-state update \
        --issue-id IW-1 \
        --display-text "Text without type" \
        --input "$TEST_TMPDIR/state.json"

    # Should fail if validation is properly enforced
    [ "$status" -eq 1 ]

    # Verify file wasn't modified
    local new_time
    new_time=$(stat -c %Y "$TEST_TMPDIR/state.json")
    [ "$original_time" -eq "$new_time" ]
}
```

### Suggestions

#### Unit Test Coverage Could Be More Comprehensive for Edge Cases
**Location:** `.iw/core/test/ReviewStateUpdaterTest.scala`
**Problem:** While the tests cover the main behaviors, they don't test some edge cases and error conditions
**Impact:** Minor - core functionality is tested, but edge cases could reveal bugs
**Recommendation:** Consider adding tests for:

```scala
// Test clearing field that doesn't exist
test("clearing non-existent field is safe"):
  val existing = """{
    "version": 2,
    "issue_id": "IW-1",
    "artifacts": [],
    "last_updated": "2026-01-01T12:00:00Z"
  }"""
  val input = ReviewStateUpdater.UpdateInput(clearMessage = true)
  val result = ReviewStateUpdater.merge(existing, input)
  val parsed = ujson.read(result)

  // Should not error, just no-op
  assert(!parsed.obj.contains("message"))

// Test setting display.subtext then clearing it
test("setting then clearing display subtext"):
  val existing = """{
    "version": 2,
    "issue_id": "IW-1",
    "artifacts": [],
    "last_updated": "2026-01-01T12:00:00Z",
    "display": {"text": "Test", "type": "info"}
  }"""
  val input1 = ReviewStateUpdater.UpdateInput(displaySubtext = Some("Added"))
  val intermediate = ReviewStateUpdater.merge(existing, input1)

  val input2 = ReviewStateUpdater.UpdateInput(clearDisplaySubtext = true)
  val result = ReviewStateUpdater.merge(intermediate, input2)
  val parsed = ujson.read(result)

  assert(!parsed("display").obj.contains("subtext"))

// Test empty array replace vs clear behavior
test("replace with empty list vs clear mode"):
  val existing = """{
    "version": 2,
    "issue_id": "IW-1",
    "artifacts": [{"label": "X", "path": "x.md"}],
    "last_updated": "2026-01-01T12:00:00Z"
  }"""

  // Replace with empty list
  val input1 = ReviewStateUpdater.UpdateInput(
    artifacts = Some(List()),
    artifactsMode = ReviewStateUpdater.ArrayMergeMode.Replace
  )
  val result1 = ReviewStateUpdater.merge(existing, input1)
  assertEquals(ujson.read(result1)("artifacts").arr.length, 0)

  // Clear mode (should be same result)
  val input2 = ReviewStateUpdater.UpdateInput(
    artifacts = Some(List(("Ignored", "ignored.md", None))),
    artifactsMode = ReviewStateUpdater.ArrayMergeMode.Clear
  )
  val result2 = ReviewStateUpdater.merge(existing, input2)
  assertEquals(ujson.read(result2)("artifacts").arr.length, 0)
```

#### E2E Tests Don't Verify Auto-Infer Issue ID Path
**Location:** `.iw/test/review-state.bats:173-404`
**Problem:** No E2E test verifies that `review-state update` correctly auto-infers the input file path from issue_id (only unit-level inference is tested in write tests)
**Impact:** Low - the logic is shared with write command which is tested, but update-specific path inference isn't verified end-to-end
**Recommendation:** Add a test that creates a file at the default location and runs update without --input flag:

```bats
@test "review-state update: auto-infer file path from branch issue_id" {
    # We are on branch IW-136, so it should find the file automatically
    local default_path="$PROJECT_ROOT/project-management/issues/IW-136/review-state.json"

    # Create state at default location
    mkdir -p "$(dirname "$default_path")"
    echo '{"version":2,"issue_id":"IW-136","artifacts":[],"last_updated":"2026-01-01T12:00:00Z"}' > "$default_path"

    # Update without --input flag
    run "$PROJECT_ROOT/iw" review-state update \
        --display-text "Auto-detected" \
        --display-type "info"
    [ "$status" -eq 0 ]

    # Verify it updated the right file
    local json
    json="$(cat "$default_path")"
    echo "$json" | python3 -c "
import json, sys
d = json.load(sys.stdin)
assert d['display']['text'] == 'Auto-detected'
"

    # Cleanup
    rm -f "$default_path"
}
```

#### Test Isolation Could Be Improved for Shared Test Resources
**Location:** `.iw/test/review-state.bats:6-14`
**Problem:** Tests reference shared test resource files in `.iw/core/test/resources/review-state/` which could be modified by other tests
**Impact:** Very low - these are read-only test fixtures, but principle of test isolation suggests each test should own its data
**Recommendation:** Consider whether these fixtures could be inlined in the tests that use them (like other tests do), or document clearly that they are read-only fixtures. Current approach is acceptable for read-only validation test data.

</review>

---

<review skill="style">

## Code Style & Documentation Review

### Formatting (Automated)
- ✅ Scalafmt applied: No manual formatting issues detected
- ✅ Line length: All lines under 100 characters
- ✅ Consistent indentation: Properly formatted

### Naming Conventions
- ✅ PascalCase for classes/traits/objects: OK
- ✅ camelCase for methods/variables: OK
- ✅ Meaningful names: OK
- Issues: **None found**

### Import Organization
- ✅ Organized by groups: OK
- ✅ No wildcard domain imports: OK (using `import iw.core.model.*` which is acceptable for internal project modules)
- Issues: **None found**

### Documentation
- ✅ PURPOSE comments present: OK
- ✅ Public APIs documented: OK (subcommand files have comprehensive header comments)
- ✅ No temporal comments: OK
- Issues: **See Critical Issues below**

### File Organization
- ✅ One primary type per file: OK
- ✅ File names match types: OK
- Issues: **None found**

### Critical Issues

#### Missing PURPOSE Comments in Core Domain File
**Location:** `.iw/core/model/ReviewStateUpdater.scala:1-2`
**Problem:** File has 2-line PURPOSE comments, but does not follow the required format
**Impact:** The PURPOSE comments use different style - each line should start with "// PURPOSE: "
**Recommendation:** Current format is acceptable and clear. Actually, on re-inspection, the file DOES follow the correct format with each line starting with "// PURPOSE:". No issue here.

### Warnings

**None found.**

### Suggestions

#### Consider More Descriptive Variable Names in Parsing Logic
**Location:** `.iw/commands/review-state/update.scala:94-140`
**Problem:** Variables like `colonIdx` and `eqIdx` use abbreviations
**Impact:** Minor readability reduction
**Recommendation:** Consider more descriptive names for clarity

```scala
// Current
val colonIdx = raw.indexOf(':')

// Suggested
val colonIndex = raw.indexOf(':')
val equalsIndex = pathAndCategory.lastIndexOf('=')
```

#### Extract Repeated Flag Parsing Pattern
**Location:** `.iw/commands/review-state/write.scala:87-138` and `.iw/commands/review-state/update.scala:94-140`
**Problem:** Similar colon-splitting and validation logic appears multiple times
**Impact:** Code duplication increases maintenance burden
**Recommendation:** Consider extracting to shared helper functions if this pattern will be reused elsewhere. However, given this is within command scripts (not core domain), current approach is acceptable.

#### Documentation: Array Merge Mode Enum Could Use More Examples
**Location:** `.iw/core/model/ReviewStateUpdater.scala:46-49`
**Problem:** Enum defines modes but lacks usage examples in doc comments
**Impact:** Minor - reduces discoverability of usage patterns
**Recommendation:** Add Scaladoc examples to the enum

```scala
/** Array merge behavior for update operations.
  *
  * @example Replace mode:
  *   {{{
  *   artifacts = Some(List(...)),
  *   artifactsMode = ArrayMergeMode.Replace
  *   }}}
  */
enum ArrayMergeMode:
  case Replace  // Replace entire array with provided values
  case Append   // Add provided values to existing array
  case Clear    // Remove all values (provided values ignored)
```

</review>

---

<review skill="security">

## Security Review

### Critical Issues

None found.

### Warnings

#### Path Traversal Risk in File Operations
**Location:** `.iw/commands/review-state/validate.scala:26-30`
**Problem:** User-provided file path is used directly with `os.Path()` without validation
**Impact:** An attacker could potentially read files outside the project directory using path traversal sequences like `../../etc/passwd`
**Recommendation:** Validate that the resolved path stays within expected boundaries

```scala
// Current code (lines 26-30)
val path = os.Path(filePaths.head, os.pwd)
if !os.exists(path) then
  Output.error(s"File not found: $path")
  sys.exit(1)
os.read(path)

// Suggested improvement
val path = os.Path(filePaths.head, os.pwd)
if !os.exists(path) then
  Output.error(s"File not found: $path")
  sys.exit(1)

// Validate path is within project directory
val normalizedPath = path.toNIO.toRealPath().normalize()
val projectRoot = os.pwd.toNIO.toRealPath().normalize()
if !normalizedPath.startsWith(projectRoot) then
  Output.error("Access denied: path outside project directory")
  sys.exit(1)

os.read(path)
```

**Same issue in:**
- `.iw/commands/review-state/write.scala:50` (--output flag)
- `.iw/commands/review-state/write.scala:170` (default output path)
- `.iw/commands/review-state/update.scala:59` (--input flag)
- `.iw/commands/review-state/update.scala:62` (default input path)

#### Command Injection via Environment Variables
**Location:** `.iw/commands/review-state.scala:42-52`
**Problem:** Environment variables `IW_COMMANDS_DIR` and `IW_CORE_DIR` are used to construct file paths without validation
**Impact:** If an attacker can control these environment variables, they could potentially make the script load and execute arbitrary Scala files
**Recommendation:** Validate that environment variables contain expected directory structures

```scala
// Current code (lines 42-52)
val commandsDir = sys.env.get("IW_COMMANDS_DIR") match
  case Some(dir) => os.Path(dir)
  case None =>
    Output.error("IW_COMMANDS_DIR environment variable not set")
    sys.exit(1)

// Suggested improvement
val commandsDir = sys.env.get("IW_COMMANDS_DIR") match
  case Some(dir) =>
    val path = os.Path(dir)
    // Verify it's within project and looks like a commands directory
    if !os.exists(path) || !os.isDir(path) then
      Output.error("IW_COMMANDS_DIR does not point to a valid directory")
      sys.exit(1)
    path
  case None =>
    Output.error("IW_COMMANDS_DIR environment variable not set")
    sys.exit(1)
```

#### Shell Command Injection via scala-cli
**Location:** `.iw/commands/review-state.scala:66-76`
**Problem:** User-provided arguments are passed directly to scala-cli via `os.proc()` without sanitization
**Impact:** While `os.proc()` with a List should prevent shell injection, malicious filenames or arguments could potentially cause issues
**Recommendation:** Validate arguments before passing to subprocess, especially file paths

```scala
// Current code (lines 66-76)
val command = List("scala-cli", "run", "-q", "--suppress-outdated-dependency-warning", scriptPath.toString) ++
              coreFiles ++
              List("--") ++
              args

// This is actually reasonably safe because os.proc() with List doesn't use shell
// However, validate that coreFiles don't contain suspicious paths
val validCoreFiles = coreFiles.filter { file =>
  val path = os.Path(file)
  os.exists(path) && path.ext == "scala"
}
```

### Suggestions

#### Input Validation for Flag Values
**Location:** `.iw/commands/review-state/write.scala:87-92`, `update.scala:110-116`
**Problem:** Flag parsing uses `String.split()` with user input but doesn't validate the resulting parts beyond count
**Impact:** Minor - could lead to confusing error messages or unexpected behavior with specially crafted input
**Recommendation:** Add validation for label and value content

```scala
// Current code (lines 87-92 in write.scala)
val badges = extractRepeatedFlag(argList, "--badge").map { raw =>
  val parts = raw.split(":", 2)
  if parts.length < 2 then
    Output.error(s"Invalid badge format '$raw', expected label:type")
    sys.exit(1)
  (parts(0), parts(1))
}

// Suggested improvement
val badges = extractRepeatedFlag(argList, "--badge").map { raw =>
  val parts = raw.split(":", 2)
  if parts.length < 2 then
    Output.error(s"Invalid badge format '$raw', expected label:type")
    sys.exit(1)
  val (label, badgeType) = (parts(0).trim, parts(1).trim)
  if label.isEmpty || badgeType.isEmpty then
    Output.error(s"Invalid badge format '$raw', label and type cannot be empty")
    sys.exit(1)
  (label, badgeType)
}
```

#### No Input Length Limits
**Location:** All command files reading user input
**Problem:** No limits on input length for stdin or file sizes
**Impact:** Could cause memory exhaustion with extremely large files or stdin input
**Recommendation:** Add reasonable size limits for JSON documents

```scala
// In validate.scala, write.scala (stdin handling)
val json =
  if useStdin then
    val input = scala.io.Source.stdin.mkString
    if input.length > 1048576 then  // 1MB limit
      Output.error("Input too large (max 1MB)")
      sys.exit(1)
    input
  else
    // similar check for file size
    if os.size(path) > 1048576 then
      Output.error("File too large (max 1MB)")
      sys.exit(1)
    os.read(path)
```

#### Sensitive Data Logging
**Location:** All error messages that echo user input
**Problem:** Error messages echo user input back, which could be logged and contain sensitive data
**Impact:** If review-state.json accidentally contains secrets, error messages will expose them
**Recommendation:** Truncate echoed input in error messages

```scala
// Current pattern in multiple places
Output.error(s"Invalid badge format '$raw', expected label:type")

// Suggested improvement
val truncated = if raw.length > 50 then s"${raw.take(47)}..." else raw
Output.error(s"Invalid badge format '$truncated', expected label:type")
```

#### JSON Injection via Unchecked String Concatenation
**Location:** `.iw/core/model/ReviewStateUpdater.scala:63-164`
**Problem:** While using ujson library properly, the merge function mutates JSON objects without explicit type checking
**Impact:** Low - ujson should handle type safety, but edge cases might exist
**Recommendation:** Add explicit type validation before mutations

```scala
// Current code (lines 100-102)
val displayObj = existing.obj.get("display") match
  case Some(obj: ujson.Obj) => obj
  case _ => ujson.Obj()

// This is actually safe - pattern matching ensures type safety
// No change needed, this is good Scala practice
```

</review>

---

## Summary

- **Critical issues:** 0 (must fix before merge)
- **Warnings:** 9 (should fix)
- **Suggestions:** 19 (nice to have)

### By Skill
- architecture: 0 critical, 2 warnings, 4 suggestions
- scala3: 0 critical, 0 warnings, 1 suggestion
- composition: 0 critical, 2 warnings, 4 suggestions
- testing: 0 critical, 1 warning, 3 suggestions
- style: 0 critical, 0 warnings, 3 suggestions
- security: 0 critical, 4 warnings, 4 suggestions

### Key Findings

**No critical issues found** - the refactoring can proceed to merge after addressing warnings.

**Top warnings to address:**
1. **Code duplication** in flag parsing (composition) - extract to shared module
2. **Array parsing logic** repeated 5 times (composition) - extract generic pattern
3. **Path traversal risk** in file operations (security) - add path validation
4. **Skipped E2E test** (testing) - implement or remove

**Notable strengths:**
- ✅ Excellent use of Scala 3 enum for ArrayMergeMode
- ✅ Good FCIS separation (pure domain logic in ReviewStateUpdater)
- ✅ Comprehensive E2E test coverage (27 tests)
- ✅ Public API documentation established
